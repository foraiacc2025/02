# Принципы структурного программирования

В основе структурного подхода к программированию лежат два базовых принципа:
- принцип «разделяй и властвуй» (декомпозиция) — принцип решения сложных проблем путем их разбиения на множество меньших независимых задач, простых для понимания и решения. Причем при решении небольших задач исключается дублирование кода, а сами их решения при необходимости переиспользуются.
- принцип иерархического упорядочивания — принцип организации составных частей проблемы в иерархические древовидные структуры с добавлением новых деталей на каждом уровне (от верхнего уровня с одной точкой входа до нижних с конкретными структурами данных и реализациями). То есть на одном и том же уровне не должно быть выполнения вычислений и операций ввода-вывода. Таким образом, при использовании структурного стиля получается, что программа строится в виде «слоеного пирога» сверху вниз. Ошибки генерируются на нижних уровнях и прокидываются на самый верх, где выводятся пользователю.

Становление и развитие структурного программирования связано с именем Эдсгера Дейкстры.
* Принцип 1. Следует отказаться от использования оператора безусловного перехода goto.
* Принцип 2. Любая программа строится из трёх базовых управляющих конструкций: последовательность, ветвление, цикл.
* Принцип 3. В программе базовые управляющие конструкции могут быть вложены друг в друга произвольным образом. Никаких других средств управления последовательностью выполнения операций не предусматривается.
* Принцип 4. Повторяющиеся фрагменты программы можно оформить в виде подпрограмм (процедур и функций). Таким же образом (в виде подпрограмм) можно оформить логически целостные фрагменты программы, даже если они не повторяются.
* Принцип 5. Каждую логически законченную группу инструкций следует оформить как блок. Блоки являются основой структурного программирования.
* Принцип 6. Все перечисленные конструкции должны иметь один вход и один выход.
* Принцип 7. Разработка программы ведётся пошагово, методом «сверху вниз» (top-down method).

Следствия и дополнения вышеизложенных принципов:

1. Запрет на использование глобальных переменных. Глобальной переменной считается любая переменная, объявленная вне тела функции.
```cpp
int x1;         // Запрещено
static int x2;  // Запрещено

int sum(int a, int b) {
    int result = a + b;  // Разрешено
    return result;
}
```
2. Не более одного выхода из функции. Исключение составляет предварительная проверка аргументов функции в начале тела функции. Однако стоит обойтись без этой проверки, если это возможно.
```cpp
int count_negative(int *arr, int n) {
    if (arr == NULL) return -1;  // Хорошо, таким образом сигнализируем об ошибке
    int count = 0;
    for (int i = 0; i < n; i++)
        if (arr[i] < 0) count++;
    return count;  // Хорошо, один выход
}

int min(int a, int b) {
    if (a < b) return a;  // Плохо, должен быть только один выход
    return b;
}

int max(int a, int b) {
    int result = b;
    if (a > b) result = a;
    return result;  // Хорошо, так как это единственный выход
}

int factorial(int n) {
    int result = 1;
    for (int i = 1; i <= n; i++) result *= i;
    if (n < 0) return -1;  // Плохо, проверка аргументов должна быть строго в начале тела функции
    return result;
}
```
3. Не более одного выхода из цикла — это может быть как условие самого цикла, так и ключевое слово break в случае бесконечного цикла. Также запрещено использовать ключевое слово `continue`, так как его поведение схоже с оператором `goto`.
```cpp
#define ARRAY_SIZE 5

int main(void) {
    int pos_zero = -1;
    int arr[ARRAY_SIZE] = {1, 2, 0, 4, 5};
    for (int i = 0; i < ARRAY_SIZE; i++)  // Первая точка выхода
        if (arr[i] == 0) {
            pos_zero = i;
            break;  // Плохо, вторая точка выхода из цикла
        }

    for (int i = 0; i < ARRAY_SIZE && pos_zero == -1; i++)  // Хорошо, единственная точка выхода
        if (arr[i] == 0) pos_zero = i;

    int i = 0;
    while (true) {
        if (i == ARRAY_SIZE || pos_zero != -1) break;  // Хорошо, так как это единственная точка выхода
        if (arr[i] == 0) pos_zero = i;
        i++;
    }

    for (int i = 0; i < ARRAY_SIZE && pos_zero == -1; i++)  // Единственная точка выхода
    {
        if (arr[i] != 0) continue;  // Запрещено
        pos_zero = i;
    }

    return 0;
}
```
4. Вложенность любых блоков не должна превышать 4. Отсчет вложенности не начинается с самой функции.
```cpp
#include <stdio.h>

#define MATRIX_COLS 3
#define MATRIX_ROWS 3

int main(void) {
    int matrix[MATRIX_ROWS][MATRIX_COLS];
    for (int i = 0; i < MATRIX_ROWS; i++)
        for (int j = 0; j < MATRIX_COLS; j++) {
            int element = matrix[i][j];

            // Подсчитываем сколько раз element встречается в матрице
            // Лучше вынести в отдельную функцию, чтобы минимизировать уровень вложенности
            int count = 0;
            for (int k = 0; k < MATRIX_ROWS; k++)
                for (int l = 0; l < MATRIX_COLS; l++)
                    if (element = matrix[k][l])  // Плохо, 5-ый уровень вложенности
                        count++;                 // Плохо, 6-ый уровень вложенности
        }
    return 0;
}
```
5. Размер функций ограничен по строкам и не превышает 42 строки, считая от начала её определения и до последней фигурной скобки.
6. Запрет на использование функции немедленного завершения программы exit().
```cpp
int sum_array(const int *arr, int n) {
    if (arr == NULL)
        exit(1);  // Плохо, лучше возвращать код ошибки и обрабатывать её извне, чем прерывать программу
    int result = 0;
    for (int i = 0; i < n; i++) result += arr[i];
    return result;
}
```

![goto](../misc/eng/images/GOTO.png)
