# Объяснение логики программ

## 1948.c - Наибольший простой делитель

**Задача:** Найти наибольший простой делитель числа.

**Логика:**
1. Программа читает число с ввода
2. Использует факторизацию через вычитание (без операторов деления и остатка)
3. Сначала делит на 2 максимально возможное количество раз
4. Затем проверяет нечётные числа от 3 до остатка
5. Последний найденный делитель будет наибольшим простым

**Ключевые функции:**
- `is_divisible(a, b)` - проверяет делимость через вычитание
- `divide_by_subtraction(a, b)` - деление через вычитание
- `largest_prime_divisor(n)` - главный алгоритм факторизации

**Пример:** Для числа 1948:
- 1948 ÷ 2 = 974
- 974 ÷ 2 = 487
- 487 - простое число
- Ответ: 487

---

## char_decode.c - Кодирование/декодирование символов в HEX

**Задача:** Кодировать текст в HEX-коды или декодировать HEX обратно в текст.

**Логика:**

**Режим 0 (кодирование):**
1. Читает символы из ввода
2. Каждый символ преобразует в HEX (например, 'H' → 48)
3. Выводит HEX-коды через пробелы

**Режим 1 (декодирование):**
1. Читает пары HEX-символов
2. Преобразует каждую пару обратно в символ
3. Выводит символы слитно (без пробелов)

**Ключевые функции:**
- `hex_to_int(c)` - преобразует символ '0'-'9', 'A'-'F' в число 0-15
- Проверка корректности ввода: `scanf("%d%c", &n, &c)` читает число и следующий символ

**Пример:**
```
Ввод: "Hi!" + режим 0
Вывод: 48 69 21

Ввод: "48 69 21" + режим 1
Вывод: Hi!
```

---

## quest3.c - Числа Фибоначчи (рекурсия)

**Задача:** Вычислить n-е число Фибоначчи рекурсивно.

**Логика:**
1. Базовые случаи: F(0) = 0, F(1) = 1
2. Рекурсивный случай: F(n) = F(n-1) + F(n-2)
3. Проверка ввода: число должно быть целым неотрицательным и без лишних символов

**Проверка ввода:**
- `scanf("%d%c", &n, &c)` читает число и следующий символ
- Если следующий символ не `\n`, значит ввод некорректный (например, "1.5", "1q")
- Это отсекает дробные числа и числа с буквами

**Пример последовательности:**
```
F(0) = 0
F(1) = 1
F(2) = 1
F(3) = 2
F(4) = 3
F(5) = 5
F(6) = 8
```

**Недостаток:** Экспоненциальная сложность O(2^n) из-за повторных вычислений.

---

## door_functions.c - Таблица значений функций

**Задача:** Вычислить и вывести таблицу значений трёх математических функций.

**Логика:**
1. Диапазон: от -π до π
2. 42 точки измерения с равномерным шагом
3. Для каждой точки вычисляются три функции:

**Функции:**
1. **Верзьера Аньези:** `y = 1 / (x² + 1)`
   - Всегда определена
   - Колоколообразная кривая

2. **Лемниската Бернулли:** `y = √(√(1 + 4x²) - x² - 1)`
   - Определена не везде
   - Если внутренний корень < 0, выводится "--"

3. **Квадратичная гипербола:** `y = 1 / x²`
   - Не определена при x = 0
   - Проверка: `|x| < 1e-10` для избежания деления на ноль

**Формат вывода:**
```
x          | Верзьера | Лемниската | Гипербола
-3.1415927 | 0.0909091 | --        | 0.1013212
```

---

## door_functions_print.c - Графики функций ASCII

**Задача:** Построить ASCII-графики трёх функций из предыдущей задачи.

**Логика разбита на этапы:**

### Этап 1: Вычисление значений (`compute_values`)
- Для 42 точек от -π до π вычисляются значения функции
- Результаты сохраняются в массив

### Этап 2: Поиск диапазона (`find_range`)
- Находим минимальное и максимальное значения среди всех точек
- Игнорируем значения -1 (точки, где функция не определена)
- Это нужно для масштабирования графика

### Этап 3: Отрисовка (`draw_graph`)
- Для каждой строки (21 строка высоты)
- Для каждой колонки (42 колонки ширины)
- Вычисляем, в какую строку попадёт значение функции
- Формула: `row = (y_max - y) × (HEIGHT - 1) / y_range`
- Если значение попадает в текущую строку → ставим '*', иначе '.'

### Этап 4: Вывод трёх графиков (`plot_function`)
- Объединяет все этапы
- Вызывается трижды для каждой функции

**Структура:**
```
Вычисление → Поиск диапазона → Отрисовка → Вывод
```

**Соответствие правилам структурного программирования:**
- Каждая функция делает одну задачу
- Нет глобальных переменных
- Один выход из каждой функции
- Вложенность не превышает 4
- Функции до 42 строк

---

## Общие принципы всех программ

1. **Структурное программирование:**
   - Разделение на функции по задачам
   - Один вход и один выход из функций
   - Нет `goto`, минимум `break`

2. **Обработка ошибок:**
   - Возврат специальных значений (-1 для невалидных результатов)
   - Проверка ввода на корректность
   - Вывод "n/a" при ошибках

3. **Читаемость:**
   - Понятные имена функций и переменных
   - Логическое разделение на этапы
   - Минимальная вложенность

4. **Эффективность вычислений:**
   - Одна переменная - одна задача
   - Минимум повторных вычислений
   - Простые алгоритмы без излишней сложности
