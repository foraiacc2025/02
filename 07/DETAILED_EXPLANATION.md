# Day 07: Подробное объяснение всех решений

## Содержание
1. [Введение в указатели и массивы](#введение-в-указатели-и-массивы)
2. [Quest 1: maxmin.c](#quest-1-maxminc)
3. [Quest 2: squaring.c](#quest-2-squaringc)
4. [Quest 3: stat.c](#quest-3-statc)
5. [Quest 4: search.c](#quest-4-searchc)
6. [Quest 5: sort.c](#quest-5-sortc)
7. [Quest 6: key9part1.c](#quest-6-key9part1c)
8. [Quest 7: cycle_shift.c](#quest-7-cycle_shiftc)
9. [Quest 8: key9part2.c (Bonus)](#quest-8-key9part2c-bonus)
10. [Принципы структурного программирования](#принципы-структурного-программирования)

---

## Введение в указатели и массивы

### Что такое указатель?
**Указатель** — это переменная, которая хранит адрес другой переменной в памяти.

```c
int x = 5;      // Обычная переменная
int *p = &x;    // p - указатель, хранящий адрес x
                // & - оператор получения адреса
                // * в объявлении означает "указатель на int"
*p = 10;        // * - оператор разыменования (обращение по адресу)
                // Теперь x == 10
```

### Связь массивов и указателей
В языке C **массив — это указатель** на первый элемент:

```c
int arr[5] = {1, 2, 3, 4, 5};
// arr == &arr[0]  (адрес первого элемента)
// arr[2] == *(arr + 2)  (третий элемент)
// 2[arr] == *(2 + arr)  (да, так тоже можно!)
```

### Арифметика указателей
```c
int *p = arr;        // p указывает на arr[0]
p++;                 // p теперь указывает на arr[1]
p = p + 2;           // p теперь указывает на arr[3]
int diff = p - arr;  // diff == 3 (разница в элементах)
```

---

## Quest 1: maxmin.c

### Задача
Найти максимум и минимум из трех чисел. Программа была с ошибками, нужно было их исправить.

### Полный код с построчными комментариями

```c
#include <stdio.h>
// Подключаем библиотеку для ввода-вывода (scanf, printf)

void maxmin(int prob1, int prob2, int prob3, int *max, int *min);
// Объявление функции maxmin:
// - принимает 3 числа (prob1, prob2, prob3)
// - принимает 2 указателя (int *max, int *min) для возврата результата
// Почему указатели? Функция может вернуть только одно значение через return,
// но нам нужно вернуть ДВА значения (max и min), поэтому используем указатели

int main() {
    int x, y, z;
    // Объявляем 3 переменные для хранения введенных чисел
    
    if (scanf("%d %d %d", &x, &y, &z) != 3) {
        // scanf возвращает количество успешно прочитанных значений
        // Мы ожидаем 3 числа, если scanf вернул не 3 - ошибка ввода
        // &x, &y, &z - передаем АДРЕСА переменных, чтобы scanf мог их изменить
        printf("n/a");
        return 0;
    }
    
    int max, min;
    // Объявляем переменные для результата
    
    maxmin(x, y, z, &max, &min);
    // Вызываем функцию:
    // - передаем значения x, y, z
    // - передаем АДРЕСА переменных max и min (оператор &)
    //   чтобы функция могла их изменить
    
    printf("%d %d", max, min);
    // Выводим результат: сначала максимум, потом минимум
    
    return 0;
}

void maxmin(int prob1, int prob2, int prob3, int *max, int *min) {
    // max и min - это УКАЗАТЕЛИ (хранят адреса переменных из main)
    
    *max = *min = prob1;
    // *max - разыменование указателя (обращение к значению по адресу)
    // Присваиваем первое число и max, и min
    // Это эквивалентно: *max = prob1; *min = prob1;
    
    if (prob2 > *max)
        // Если второе число больше текущего максимума
        *max = prob2;
        // Обновляем максимум
    
    if (prob2 < *min)
        // Если второе число меньше текущего минимума
        *min = prob2;
        // Обновляем минимум
    
    if (prob3 > *max)
        *max = prob3;
        // Аналогично проверяем третье число
    
    if (prob3 < *min)
        *min = prob3;
}
```

### Какие ошибки были исправлены?

1. **Отсутствовали амперсанды в scanf**:
   ```c
   // Было (НЕПРАВИЛЬНО):
   scanf("%d %d", x, y, z);  // передаем значения
   
   // Стало (ПРАВИЛЬНО):
   scanf("%d %d %d", &x, &y, &z);  // передаем адреса
   ```

2. **Параметр min не был указателем**:
   ```c
   // Было:
   void maxmin(..., int *max, int min)  // min - обычная переменная
   
   // Стало:
   void maxmin(..., int *max, int *min)  // min - указатель
   ```

3. **Неправильные сравнения с указателями**:
   ```c
   // Было:
   if (prob2 > max)  // сравниваем с АДРЕСОМ (НЕПРАВИЛЬНО)
   
   // Стало:
   if (prob2 > *max)  // сравниваем со ЗНАЧЕНИЕМ (ПРАВИЛЬНО)
   ```

4. **Не передавались адреса при вызове**:
   ```c
   // Было:
   maxmin(x, y, z, max, min);  // передаем значения
   
   // Стало:
   maxmin(x, y, z, &max, &min);  // передаем адреса
   ```

### Как работает программа?

1. Считываем 3 числа
2. Инициализируем max и min первым числом
3. Последовательно сравниваем каждое число с max и min
4. Обновляем max и min при необходимости
5. Возвращаем результат через указатели

**Пример**: Ввод `1 2 3`
- Изначально: max=1, min=1
- Проверяем 2: max=2, min=1
- Проверяем 3: max=3, min=1
- Результат: `3 1`

---

## Quest 2: squaring.c

### Задача
Возвести каждый элемент массива в квадрат. Программа имела ошибки.

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 10
// Определяем константу - максимальный размер массива
// #define - директива препроцессора, выполняется ДО компиляции
// NMAX будет заменено на 10 во всём коде

int input(int *a, int *n);
// Функция ввода:
// - int *a - указатель на массив (на его первый элемент)
// - int *n - указатель на переменную для количества элементов
// - возвращает 1 при успехе, 0 при ошибке

void output(int *a, int n);
// Функция вывода:
// - int *a - указатель на массив
// - int n - количество элементов (обычное значение, не указатель)

void squaring(int *a, int n);
// Функция возведения в квадрат

int main() {
    int n, data[NMAX];
    // n - количество элементов
    // data[NMAX] - массив из 10 элементов
    // data - это указатель на первый элемент
    
    if (input(data, &n) == 0) {
        // Вызываем input:
        // - data - имя массива само по себе является указателем
        // - &n - адрес переменной n
        // Если input вернула 0 - произошла ошибка
        printf("n/a");
        return 0;
    }
    
    squaring(data, n);
    // Возводим элементы в квадрат
    // data - передаем массив (указатель)
    // n - передаем значение
    
    output(data, n);
    // Выводим результат
    
    return 0;
}

int input(int *a, int *n) {
    // a - указатель на массив
    // n - указатель на количество элементов
    
    if (scanf("%d", n) != 1 || *n <= 0 || *n > NMAX) {
        // Проверяем три условия:
        // 1. scanf("%d", n) != 1 - не удалось считать число
        // 2. *n <= 0 - количество элементов не положительное
        // 3. *n > NMAX - количество больше максимума
        // || - логическое ИЛИ (хотя бы одно условие истинно)
        return 0;  // Возвращаем 0 = ошибка
    }
    
    for (int *p = a; p - a < *n; p++) {
        // Цикл с указателем:
        // int *p = a - p указывает на первый элемент массива
        // p - a < *n - разница указателей дает индекс элемента
        //              продолжаем пока индекс < количества элементов
        // p++ - переходим к следующему элементу
        
        if (scanf("%d", p) != 1) {
            // Читаем элемент напрямую по адресу p
            // p уже указатель, поэтому & не нужен
            return 0;
        }
    }
    return 1;  // Успех
}

void output(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        // Цикл по массиву с указателем
        
        if (p != a) {
            // Если это НЕ первый элемент
            printf(" ");
            // Выводим пробел перед числом
        }
        printf("%d", *p);
        // *p - значение элемента по адресу p
    }
}

void squaring(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        *p = (*p) * (*p);
        // *p - текущий элемент
        // (*p) * (*p) - квадрат элемента
        // *p = ... - присваиваем результат обратно
        // Скобки для ясности (хотя не обязательны)
    }
}
```

### Какие ошибки были исправлены?

1. **Неправильный вызов input в main**:
   ```c
   // Было:
   input(data, n);  // передаем значение n
   
   // Стало:
   input(data, &n);  // передаем адрес n
   ```

2. **Функция input не возвращала значение**:
   ```c
   // Было:
   int input(int *a, int *n) {
       scanf("%d", n);
       for(...) { scanf("%d", p); }
   }  // Отсутствует return!
   
   // Стало:
   int input(int *a, int *n) {
       if (scanf(...) != 1 || ...) return 0;
       for(...) { if (scanf(...) != 1) return 0; }
       return 1;
   }
   ```

3. **Функции output и squaring не были реализованы**

### Арифметика указателей в деталях

```c
int arr[5] = {10, 20, 30, 40, 50};
int *p = arr;

// p указывает на arr[0]
// p - arr == 0 (разница в элементах)
// *p == 10

p++;  // p теперь указывает на arr[1]
// p - arr == 1
// *p == 20

p = p + 2;  // p указывает на arr[3]
// p - arr == 3
// *p == 40
```

**Важно**: `p - a` дает индекс элемента, на который указывает `p`

---

## Quest 3: stat.c

### Задача
Вычислить статистические метрики массива: max, min, среднее, дисперсию.

### Математические формулы

**Среднее арифметическое (математическое ожидание)**:
```
mean = (x₁ + x₂ + ... + xₙ) / n
```

**Дисперсия**:
```
variance = ((x₁-mean)² + (x₂-mean)² + ... + (xₙ-mean)²) / n
```

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 10

int input(int *a, int *n);
void output(int *a, int n);
int max(int *a, int n);          // Возвращает максимум
int min(int *a, int n);          // Возвращает минимум
double mean(int *a, int n);      // Возвращает среднее (double!)
double variance(int *a, int n);  // Возвращает дисперсию (double!)

void output_result(int max_v, int min_v, double mean_v, double variance_v);
// Функция вывода результата

int main() {
    int n, data[NMAX];
    
    if (input(data, &n) == 0) {
        printf("n/a");
        return 0;
    }
    
    output(data, n);
    printf("\n");
    // \n - символ перевода строки
    
    output_result(max(data, n),      // Вычисляем max
                  min(data, n),      // Вычисляем min
                  mean(data, n),     // Вычисляем среднее
                  variance(data, n)); // Вычисляем дисперсию
    // Все функции вызываются прямо в аргументах output_result
    
    return 0;
}

int input(int *a, int *n) {
    if (scanf("%d", n) != 1 || *n <= 0 || *n > NMAX) {
        return 0;
    }
    for (int *p = a; p - a < *n; p++) {
        if (scanf("%d", p) != 1) {
            return 0;
        }
    }
    return 1;
}

void output(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        if (p != a) {
            printf(" ");
        }
        printf("%d", *p);
    }
}

int max(int *a, int n) {
    int max_val = *a;
    // Инициализируем максимум первым элементом
    // *a - разыменование указателя a (первый элемент)
    
    for (int *p = a + 1; p - a < n; p++) {
        // Начинаем со второго элемента: a + 1
        // a + 1 - указатель на второй элемент
        
        if (*p > max_val) {
            // Если текущий элемент больше max_val
            max_val = *p;
            // Обновляем максимум
        }
    }
    return max_val;
}

int min(int *a, int n) {
    int min_val = *a;
    // Инициализируем минимум первым элементом
    
    for (int *p = a + 1; p - a < n; p++) {
        if (*p < min_val) {
            min_val = *p;
        }
    }
    return min_val;
}

double mean(int *a, int n) {
    // Возвращаем double, т.к. среднее может быть дробным
    
    double sum = 0.0;
    // sum - типа double для точности
    // 0.0 - литерал double (0 был бы int)
    
    for (int *p = a; p - a < n; p++) {
        sum += *p;
        // sum = sum + *p
        // *p (int) автоматически преобразуется в double
    }
    return sum / n;
    // Деление double на int дает double
}

double variance(int *a, int n) {
    double mean_val = mean(a, n);
    // Сначала вычисляем среднее
    
    double sum = 0.0;
    // Сумма квадратов отклонений
    
    for (int *p = a; p - a < n; p++) {
        double diff = *p - mean_val;
        // Отклонение элемента от среднего
        // *p (int) преобразуется в double
        
        sum += diff * diff;
        // Квадрат отклонения
    }
    return sum / n;
    // Дисперсия = среднее квадратов отклонений
}

void output_result(int max_v, int min_v, double mean_v, double variance_v) {
    printf("%d %d %f %f", max_v, min_v, mean_v, variance_v);
    // %d - формат для int
    // %f - формат для double (по умолчанию 6 знаков после запятой)
}
```

### Пример работы программы

Ввод: `4\n1 2 3 4`

1. **Чтение**: массив [1, 2, 3, 4]
2. **Вывод массива**: `1 2 3 4`
3. **Max**: 4
4. **Min**: 1
5. **Mean**: (1+2+3+4)/4 = 10/4 = 2.5
6. **Variance**: 
   - Отклонения: (1-2.5)², (2-2.5)², (3-2.5)², (4-2.5)²
   - = 2.25 + 0.25 + 0.25 + 2.25 = 5
   - Дисперсия = 5/4 = 1.25
7. **Вывод**: `4 1 2.500000 1.250000`

---

## Quest 4: search.c

### Задача
Найти первое число, удовлетворяющее условиям:
- Четное
- >= среднего
- В пределах 3 сигм (правило трех сигм)
- ≠ 0

### Что такое "правило трех сигм"?

**Сигма (σ)** = стандартное отклонение = √дисперсия

**Правило трех сигм**: 99.7% значений лежат в диапазоне [μ - 3σ, μ + 3σ]

В нашем случае проверяем: `число <= среднее + 3 * √дисперсия`

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 30
// Максимум 30 элементов (по заданию)

int input(int *a, int *n);
double mean(int *a, int n);
double variance(int *a, int n);
double my_sqrt(double x);        // Наша функция вычисления корня
int search(int *a, int n);       // Функция поиска

int main() {
    int n, data[NMAX];
    if (input(data, &n) == 0) {
        printf("n/a");
        return 0;
    }
    printf("%d", search(data, n));
    return 0;
}

int input(int *a, int *n) {
    if (scanf("%d", n) != 1 || *n <= 0 || *n > NMAX) {
        return 0;
    }
    for (int *p = a; p - a < *n; p++) {
        if (scanf("%d", p) != 1) {
            return 0;
        }
    }
    return 1;
}

double mean(int *a, int n) {
    double sum = 0.0;
    for (int *p = a; p - a < n; p++) {
        sum += *p;
    }
    return sum / n;
}

double variance(int *a, int n) {
    double mean_val = mean(a, n);
    double sum = 0.0;
    for (int *p = a; p - a < n; p++) {
        double diff = *p - mean_val;
        sum += diff * diff;
    }
    return sum / n;
}

double my_sqrt(double x) {
    // Метод Ньютона для вычисления квадратного корня
    // Нельзя использовать sqrt из math.h (нет stdlib.h по заданию)
    
    double result = 0.0;
    // Результат по умолчанию
    
    if (x > 0) {
        // Корень существует только для положительных чисел
        
        double guess = x / 2.0;
        // Начальное приближение: половина от x
        
        double epsilon = 0.00001;
        // Точность (погрешность)
        
        double diff = epsilon + 1;
        // Разница между итерациями (изначально больше epsilon)
        
        while (diff >= epsilon || diff <= -epsilon) {
            // Продолжаем, пока |diff| >= epsilon
            // diff >= epsilon - проверяет положительную разницу
            // diff <= -epsilon - проверяет отрицательную разницу
            // || - логическое ИЛИ
            
            double new_guess = (guess + x / guess) / 2.0;
            // Формула Ньютона: x_{n+1} = (x_n + a/x_n) / 2
            
            diff = new_guess - guess;
            // Насколько изменилось приближение
            
            guess = new_guess;
            // Обновляем приближение
        }
        result = guess;
    }
    
    return result;
}

int search(int *a, int n) {
    double mean_val = mean(a, n);
    // Вычисляем среднее
    
    double var = variance(a, n);
    // Вычисляем дисперсию
    
    double std_dev = my_sqrt(var);
    // Стандартное отклонение = √дисперсия
    
    double upper_bound = mean_val + 3 * std_dev;
    // Верхняя граница: μ + 3σ
    
    for (int *p = a; p - a < n; p++) {
        // Проходим по массиву
        
        if (*p != 0 &&              // Не ноль
            *p % 2 == 0 &&          // Четное (*p делится на 2 без остатка)
            *p >= mean_val &&       // >= среднего
            *p <= upper_bound) {    // <= верхней границы
            
            // && - логическое И (все условия должны быть истинны)
            
            return *p;
            // Возвращаем первое подходящее число
        }
    }
    
    return 0;
    // Если ничего не найдено, возвращаем 0
}
```

### Метод Ньютона для квадратного корня

Формула: `x_{n+1} = (x_n + a/x_n) / 2`

Пример для √16:
1. x₀ = 8 (начальное)
2. x₁ = (8 + 16/8) / 2 = (8 + 2) / 2 = 5
3. x₂ = (5 + 16/5) / 2 = (5 + 3.2) / 2 = 4.1
4. x₃ = (4.1 + 16/4.1) / 2 ≈ 4.0012...
5. x₄ ≈ 4.0000015...

Метод быстро сходится к правильному ответу!

### Пример работы

Ввод: `4\n1 2 3 4`
- mean = 2.5
- variance = 1.25
- std_dev = √1.25 ≈ 1.118
- upper_bound = 2.5 + 3*1.118 ≈ 5.854

Проверяем элементы:
- 1: нечетное ❌
- 2: четное ✓, 2 < 2.5 ❌
- 3: нечетное ❌
- 4: четное ✓, 4 >= 2.5 ✓, 4 <= 5.854 ✓, 4 != 0 ✓

**Результат**: 4

---

## Quest 5: sort.c

### Задача
Отсортировать массив из 10 чисел по возрастанию (без stdlib.h).

### Алгоритм: Пузырьковая сортировка

**Идея**: "Всплывают" наибольшие элементы в конец массива.

**Процесс**:
1. Сравниваем соседние элементы
2. Если левый > правого, меняем местами
3. Повторяем n-1 раз

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 10

int input(int *a, int n);
void output(int *a, int n);
void sort(int *a, int n);

int main() {
    int data[NMAX];
    
    if (input(data, NMAX) == 0) {
        // Читаем ровно NMAX элементов
        printf("n/a");
        return 0;
    }
    
    sort(data, NMAX);
    output(data, NMAX);
    return 0;
}

int input(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        if (scanf("%d", p) != 1) {
            return 0;
        }
    }
    return 1;
}

void output(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        if (p != a) {
            printf(" ");
        }
        printf("%d", *p);
    }
}

void sort(int *a, int n) {
    // Пузырьковая сортировка с указателями
    
    for (int *i = a; i - a < n - 1; i++) {
        // Внешний цикл: n-1 проход
        // i - указатель, отмечающий границу отсортированной части
        
        for (int *j = a; j - a < n - 1 - (i - a); j++) {
            // Внутренний цикл: сравниваем соседние элементы
            // j - указатель на текущий элемент
            // j - a - индекс текущего элемента
            // n - 1 - (i - a) - количество сравнений на этом проходе
            //   уменьшается, т.к. конец уже отсортирован
            
            if (*j > *(j + 1)) {
                // Если текущий элемент больше следующего
                // *j - значение по адресу j
                // *(j + 1) - значение по адресу следующего элемента
                
                int temp = *j;
                // Сохраняем текущий элемент
                
                *j = *(j + 1);
                // Копируем следующий элемент в текущий
                
                *(j + 1) = temp;
                // Копируем сохраненное значение в следующий
                // Элементы поменялись местами!
            }
        }
    }
}
```

### Визуализация сортировки

Массив: [4, 2, 5, 1, 3]

**Проход 1**:
- [4,2] → [2,4,5,1,3] (поменяли)
- [4,5] → [2,4,5,1,3] (не меняем)
- [5,1] → [2,4,1,5,3] (поменяли)
- [5,3] → [2,4,1,3,5] (поменяли)
- Самое большое (5) "всплыло" в конец

**Проход 2**:
- [2,4] → [2,4,1,3,5]
- [4,1] → [2,1,4,3,5]
- [4,3] → [2,1,3,4,5]
- Второе по величине (4) на месте

...и так далее...

**Результат**: [1, 2, 3, 4, 5]

### Сложность алгоритма

- **Время**: O(n²) - два вложенных цикла
- **Память**: O(1) - сортировка на месте

---

## Quest 6: key9part1.c

### Задача
1. Найти сумму четных элементов
2. Найти элементы, на которые эта сумма делится нацело
3. Вывести сумму и новый массив

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 10

void input(int *buffer, int *length);
void output(int *buffer, int length);
int sum_numbers(int *buffer, int length);
int find_numbers(int* buffer, int length, int number, int* numbers);

int main() {
    int n, buffer[NMAX];
    input(buffer, &n);
    // Читаем массив
    
    int sum = sum_numbers(buffer, n);
    // Вычисляем сумму четных
    
    if (sum == 0) {
        // Если сумма = 0 (нет четных элементов)
        printf("n/a");
        return 0;
    }
    
    int numbers[NMAX];
    // Массив для результата
    
    int count = find_numbers(buffer, n, sum, numbers);
    // Ищем элементы, на которые делится sum
    
    if (count == 0) {
        // Если ничего не найдено
        printf("n/a");
        return 0;
    }
    
    printf("%d\n", sum);
    // Выводим сумму и переход на новую строку
    
    output(numbers, count);
    // Выводим найденные элементы
    
    return 0;
}

void input(int *buffer, int *length) {
    if (scanf("%d", length) == 1) {
        // Проверяем успешность чтения количества
        
        for (int *p = buffer; p - buffer < *length; p++) {
            scanf("%d", p);
            // Читаем элементы
        }
    }
}

void output(int *buffer, int length) {
    for (int *p = buffer; p - buffer < length; p++) {
        if (p != buffer) {
            printf(" ");
        }
        printf("%d", *p);
    }
}

int sum_numbers(int *buffer, int length) {
    // Находим сумму ЧЕТНЫХ элементов (0 считаем нечетным)
    
    int sum = 0;
    
    for (int *p = buffer; p - buffer < length; p++) {
        if (*p % 2 == 0 && *p != 0) {
            // % - оператор остатка от деления
            // *p % 2 == 0 - четное число
            // && - логическое И (оба условия должны быть истинны)
            // *p != 0 - не ноль (по заданию 0 нечетное)
            
            sum = sum + *p;
        }
    }
    
    return sum;
}

int find_numbers(int* buffer, int length, int number, int* numbers) {
    // Находим элементы, на которые number делится нацело
    
    int count = 0;
    // Счетчик найденных элементов
    
    for (int *p = buffer; p - buffer < length; p++) {
        if (*p != 0 && number % *p == 0) {
            // *p != 0 - не делим на ноль!
            // number % *p == 0 - number делится на *p нацело
            
            numbers[count] = *p;
            // Добавляем элемент в результирующий массив
            
            count++;
            // Увеличиваем счетчик
        }
    }
    
    return count;
    // Возвращаем количество найденных элементов
}
```

### Пример работы

Ввод: `10\n4 3 9 0 1 2 0 2 7 -1`

**Шаг 1**: Сумма четных
- 4: четное ✓ → sum = 4
- 3: нечетное ❌
- 9: нечетное ❌
- 0: ноль (считаем нечетным) ❌
- 1: нечетное ❌
- 2: четное ✓ → sum = 6
- 0: ноль ❌
- 2: четное ✓ → sum = 8
- 7: нечетное ❌
- -1: нечетное ❌
**sum = 8**

**Шаг 2**: Элементы, на которые 8 делится нацело
- 4: 8 % 4 = 0 ✓
- 3: 8 % 3 = 2 ❌
- 9: 8 % 9 = 8 ❌
- 0: пропускаем ❌
- 1: 8 % 1 = 0 ✓
- 2: 8 % 2 = 0 ✓
- 0: пропускаем ❌
- 2: 8 % 2 = 0 ✓
- 7: 8 % 7 = 1 ❌
- -1: 8 % -1 = 0 ✓

**Результат**: 
```
8
4 1 2 2 -1
```

---

## Quest 7: cycle_shift.c

### Задача
Циклически сдвинуть массив влево на c позиций (если c < 0, то вправо).

### Что такое циклический сдвиг?

**Влево на 2**: [1,2,3,4,5] → [3,4,5,1,2]
**Вправо на 1** (влево на -1): [1,2,3,4,5] → [5,1,2,3,4]

### Полный код с построчными комментариями

```c
#include <stdio.h>
#define NMAX 10

int input(int *a, int *n, int *c);
void output(int *a, int n);
void cycle_shift(int *a, int n, int c);

int main() {
    int n, c, data[NMAX];
    
    if (input(data, &n, &c) == 0) {
        printf("n/a");
        return 0;
    }
    
    cycle_shift(data, n, c);
    output(data, n);
    return 0;
}

int input(int *a, int *n, int *c) {
    if (scanf("%d", n) != 1 || *n <= 0 || *n > NMAX) {
        return 0;
    }
    
    for (int *p = a; p - a < *n; p++) {
        if (scanf("%d", p) != 1) {
            return 0;
        }
    }
    
    if (scanf("%d", c) != 1) {
        // Читаем величину сдвига
        return 0;
    }
    
    return 1;
}

void output(int *a, int n) {
    for (int *p = a; p - a < n; p++) {
        if (p != a) {
            printf(" ");
        }
        printf("%d", *p);
    }
}

void cycle_shift(int *a, int n, int c) {
    if (n > 1) {
        // Сдвигать имеет смысл только если элементов > 1
        
        c = c % n;
        // Нормализуем сдвиг:
        // Если c >= n, достаточно сдвинуть на остаток
        // Пример: сдвиг на 12 в массиве из 10 = сдвиг на 2
        // % - оператор остатка от деления
        
        if (c < 0) {
            c += n;
            // Если c отрицательное (сдвиг вправо)
            // Преобразуем в эквивалентный сдвиг влево
            // Пример: -2 в массиве из 10 = сдвиг влево на 8
        }
        
        // Выполняем сдвиг влево c раз
        for (int shift = 0; shift < c; shift++) {
            // Каждая итерация - сдвиг на 1 позицию влево
            
            int temp = *a;
            // Сохраняем первый элемент
            
            for (int *p = a; p - a < n - 1; p++) {
                // Сдвигаем все элементы влево на 1
                *p = *(p + 1);
                // Текущий = следующий
            }
            
            *(a + n - 1) = temp;
            // Последний = сохраненный первый
            // a + n - 1 - указатель на последний элемент
        }
    }
}
```

### Визуализация циклического сдвига влево на 2

Массив: [1, 2, 3, 4, 5]

**Сдвиг 1** (shift = 0):
- temp = 1
- [2, 3, 4, 5, _]  (сдвинули влево)
- [2, 3, 4, 5, 1]  (поставили temp в конец)

**Сдвиг 2** (shift = 1):
- temp = 2
- [3, 4, 5, 1, _]
- [3, 4, 5, 1, 2]

**Результат**: [3, 4, 5, 1, 2] ✓

### Обработка отрицательного сдвига

Сдвиг вправо на 2 = сдвиг влево на (n - 2)

Массив из 5 элементов:
- c = -2 (вправо на 2)
- c = c % 5 = -2
- c = -2 + 5 = 3 (влево на 3)
- Проверка: [1,2,3,4,5] вправо на 2 = [4,5,1,2,3]
- [1,2,3,4,5] влево на 3 = [4,5,1,2,3] ✓

---

## Quest 8: key9part2.c (Bonus)

### Задача
Длинная арифметика: сложение и вычитание очень больших чисел (до 100 цифр).

### Проблема
```c
int x = 123456789012345;  // Переполнение! int хранит до ~2 млрд
```

### Решение
Храним число как массив цифр:
```
19446744073709551614 → [1,9,4,4,6,7,4,4,0,7,3,7,0,9,5,5,1,6,1,4]
```

### Алгоритм сложения (столбиком)

```
    1 9 4
  +   2 9
  -------
    2 2 3
```

С переносом:
```
    1 9 4
  +   5 9
  -------
  1 carry
    2 5 3
```

### Полный код с построчными комментариями

```c
#include <stdio.h>

#define LEN 100
// Максимальная длина числа

void sum(int *buff1, int len1, int *buff2, int len2, int *result, int *result_length);
void sub(int *buff1, int len1, int *buff2, int len2, int *result, int *result_length);
int input(int *buff, int *len);
void output(int *buff, int len);
int compare(int *buff1, int len1, int *buff2, int len2);

int main() {
    int buff1[LEN], buff2[LEN];
    int len1, len2;
    
    if (input(buff1, &len1) == 0 || input(buff2, &len2) == 0) {
        // Читаем два числа
        // || - логическое ИЛИ (ошибка в любом из чтений)
        printf("n/a");
        return 0;
    }
    
    int result_sum[LEN + 1];
    // +1 для возможного переноса (9+9 может дать 18)
    
    int result_sub[LEN];
    int len_sum, len_sub;
    
    sum(buff1, len1, buff2, len2, result_sum, &len_sum);
    output(result_sum, len_sum);
    printf("\n");
    
    sub(buff1, len1, buff2, len2, result_sub, &len_sub);
    if (len_sub == -1) {
        // -1 означает ошибку (вычитаемое > уменьшаемого)
        printf("n/a");
    } else {
        output(result_sub, len_sub);
    }
    
    return 0;
}

int input(int *buff, int *len) {
    char c = ' ';
    // Символ после числа (пробел или \n)
    
    *len = 0;
    int error = 0;
    
    while (c != '\n' && *len < LEN && error == 0) {
        // Читаем до конца строки или до LEN цифр
        
        if (scanf("%d%c", &buff[*len], &c) != 2) {
            // Читаем цифру и следующий символ
            // Если не удалось прочитать оба - ошибка
            error = 1;
        } else if (buff[*len] < 0 || buff[*len] > 9) {
            // Проверяем, что это цифра (0-9)
            error = 1;
        } else {
            (*len)++;
            // Увеличиваем счетчик цифр
        }
    }
    
    return (error == 0 && *len > 0) ? 1 : 0;
    // Тернарный оператор: условие ? значение_если_истина : значение_если_ложь
}

void output(int *buff, int len) {
    for (int i = 0; i < len; i++) {
        if (i > 0) {
            printf(" ");
        }
        printf("%d", buff[i]);
    }
}

int compare(int *buff1, int len1, int *buff2, int len2) {
    // Сравнивает два числа
    // Возвращает: 1 если buff1 > buff2
    //            -1 если buff1 < buff2
    //             0 если buff1 == buff2
    
    int result = 0;
    
    if (len1 > len2) {
        // Больше цифр → больше число
        result = 1;
    } else if (len1 < len2) {
        result = -1;
    } else {
        // Одинаковая длина - сравниваем поцифренно
        int i = 0;
        while (i < len1 && result == 0) {
            // Идем слева направо (старшие разряды)
            if (buff1[i] > buff2[i]) {
                result = 1;
            } else if (buff1[i] < buff2[i]) {
                result = -1;
            }
            i++;
        }
    }
    
    return result;
}

void sum(int *buff1, int len1, int *buff2, int len2, int *result, int *result_length) {
    // Сложение столбиком справа налево
    
    int carry = 0;
    // Перенос в следующий разряд
    
    int max_len = (len1 > len2) ? len1 : len2;
    // Определяем максимальную длину
    
    *result_length = 0;
    
    for (int i = 0; i < max_len || carry; i++) {
        // i - индекс справа (0 = последняя цифра)
        // Продолжаем пока есть цифры или перенос
        
        int digit1 = (len1 - 1 - i >= 0) ? buff1[len1 - 1 - i] : 0;
        // len1 - 1 - i - индекс i-той цифры справа
        // Если индекс < 0, берем 0
        
        int digit2 = (len2 - 1 - i >= 0) ? buff2[len2 - 1 - i] : 0;
        
        int sum_digit = digit1 + digit2 + carry;
        // Складываем цифры + перенос
        
        carry = sum_digit / 10;
        // Целая часть от деления на 10 = перенос
        // Пример: 17 / 10 = 1
        
        result[i] = sum_digit % 10;
        // Остаток от деления на 10 = младшая цифра
        // Пример: 17 % 10 = 7
        
        (*result_length)++;
    }
    
    // Результат получился в обратном порядке - переворачиваем
    for (int i = 0; i < *result_length / 2; i++) {
        int temp = result[i];
        result[i] = result[*result_length - 1 - i];
        result[*result_length - 1 - i] = temp;
    }
}

void sub(int *buff1, int len1, int *buff2, int len2, int *result, int *result_length) {
    // Вычитание столбиком
    
    if (compare(buff1, len1, buff2, len2) < 0) {
        // Если buff1 < buff2, результат отрицательный
        // По заданию выводим n/a
        *result_length = -1;
        return;
    }
    
    int borrow = 0;
    // Заем из следующего разряда
    
    *result_length = 0;
    
    for (int i = 0; i < len1; i++) {
        // Идем справа налево
        
        int digit1 = buff1[len1 - 1 - i];
        int digit2 = (len2 - 1 - i >= 0) ? buff2[len2 - 1 - i] : 0;
        
        int diff = digit1 - digit2 - borrow;
        // Вычитаем цифры и заем
        
        if (diff < 0) {
            // Если результат отрицательный, берем 10 у старшего разряда
            diff += 10;
            borrow = 1;
        } else {
            borrow = 0;
        }
        
        result[i] = diff;
        (*result_length)++;
    }
    
    // Убираем ведущие нули
    while (*result_length > 1 && result[*result_length - 1] == 0) {
        (*result_length)--;
    }
    
    // Переворачиваем результат
    for (int i = 0; i < *result_length / 2; i++) {
        int temp = result[i];
        result[i] = result[*result_length - 1 - i];
        result[*result_length - 1 - i] = temp;
    }
}
```

### Пример сложения

```
  1 9 4
+   2 9
-------
```

**Справа налево**:
- i=0: 4 + 9 = 13 → цифра=3, carry=1
- i=1: 9 + 2 + 1 = 12 → цифра=2, carry=1
- i=2: 1 + 0 + 1 = 2 → цифра=2, carry=0

Результат (обратный): [3, 2, 2]
Переворачиваем: [2, 2, 3]

**Ответ**: 223 ✓

### Пример вычитания

```
  1 9 4
-   2 9
-------
```

**Справа налево**:
- i=0: 4 - 9 = -5 → берем 10: 14 - 9 = 5, borrow=1
- i=1: 9 - 2 - 1 = 6, borrow=0
- i=2: 1 - 0 - 0 = 1, borrow=0

Результат (обратный): [5, 6, 1]
Переворачиваем: [1, 6, 5]

**Ответ**: 165 ✓

---

## Принципы структурного программирования

### Соблюденные принципы

#### ✅ Принцип 1: Отказ от goto
Во всех программах не используется оператор `goto`.

#### ✅ Принцип 2: Только базовые конструкции
Используются только:
- **Последовательность**: команды идут одна за другой
- **Ветвление**: `if/else`
- **Цикл**: `for`, `while`

#### ✅ Принцип 3: Один выход из цикла
Исправили все циклы:
```c
// Было (НЕПРАВИЛЬНО):
while (1) {
    if (условие) break;  // Два выхода!
}

// Стало (ПРАВИЛЬНО):
while (условие) {
    // Один выход через условие цикла
}
```

#### ✅ Принцип 4: Декомпозиция
Каждая логическая операция вынесена в функцию:
- `input()` - ввод
- `output()` - вывод
- `mean()` - среднее
- `variance()` - дисперсия
- и т.д.

#### ✅ Принцип 5: Блоки
Логически законченные фрагменты оформлены блоками `{ }`.

#### ✅ Принцип 6: Один вход, один выход
```c
// Хорошо:
int max(int a, int b) {
    int result = b;
    if (a > b) result = a;
    return result;  // Один return
}

// Плохо (исправили):
int max(int a, int b) {
    if (a > b) return a;  // Много return!
    return b;
}
```

#### ✅ Принцип 7: Top-down
Программа строится сверху вниз:
1. `main()` - верхний уровень
2. `input()`, `process()`, `output()` - средний уровень
3. Вспомогательные функции - нижний уровень

### Дополнительные правила

#### ✅ Нет глобальных переменных
Все переменные объявлены внутри функций.

#### ✅ Размер функций <= 42 строк
Все функции компактные и понятные.

#### ✅ Вложенность <= 4 уровней
```c
void function() {        // Не считается
    if (...) {           // Уровень 1
        for (...) {      // Уровень 2
            if (...) {   // Уровень 3
                // ...   // Уровень 4
            }
        }
    }
}
```

#### ✅ Нет `exit()`
Вместо аварийного завершения возвращаем код ошибки.

---

## Ключевые концепции, которые нужно понимать

### 1. Указатели
```c
int x = 5;
int *p = &x;    // p хранит адрес x
*p = 10;        // изменяем x через указатель
```

### 2. Передача по указателю vs по значению
```c
// По значению - копия, изменения не влияют на оригинал
void f1(int x) { x = 10; }
int a = 5;
f1(a);  // a == 5 (не изменилось)

// По указателю - изменяем оригинал
void f2(int *x) { *x = 10; }
f2(&a);  // a == 10 (изменилось!)
```

### 3. Массивы = Указатели
```c
int arr[5];
arr == &arr[0]           // истина
arr[i] == *(arr + i)     // истина
```

### 4. Арифметика указателей
```c
int *p = arr;
p++;           // следующий элемент
p - arr;       // индекс элемента
```

### 5. Операторы
- `&` - взять адрес
- `*` - разыменовать (получить значение)
- `%` - остаток от деления
- `&&` - логическое И
- `||` - логическое ИЛИ
- `!` - логическое НЕ
- `++` - инкремент (увеличить на 1)
- `+=` - сложение с присваиванием

---

## Советы по отладке

### 1. Проверяйте границы массивов
```c
if (index >= 0 && index < size) {
    // безопасно обращаться к array[index]
}
```

### 2. Инициализируйте переменные
```c
int x;        // НЕ инициализирован - мусор!
int y = 0;    // Инициализирован - всё хорошо
```

### 3. Проверяйте результаты scanf
```c
if (scanf("%d", &x) != 1) {
    // Ошибка ввода!
}
```

### 4. Используйте printf для отладки
```c
printf("DEBUG: x = %d, p = %p\n", x, (void*)p);
// %d - число
// %p - адрес
```

---

## Заключение

Вы изучили:
- ✅ Работу с указателями и массивами
- ✅ Арифметику указателей
- ✅ Передачу массивов в функции
- ✅ Декомпозицию программ
- ✅ Статистические вычисления
- ✅ Алгоритмы сортировки и поиска
- ✅ Длинную арифметику
- ✅ Принципы структурного программирования

**Главное**: Указатели - это мощный инструмент. Используйте их осторожно, всегда проверяйте границы и инициализируйте переменные!

---

*Этот документ создан для полного понимания каждой строки кода.*
